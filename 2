use super::Mapper;
use std::fmt;
use crate::mapper::Mirroring;
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
extern {
    #[wasm_bindgen(js_namespace = console)] fn log(s: &str);
}

const PRG_BANK_SIZE: usize = 0x4000;
const CHR_BANK_SIZE: usize = 0x2000;

use Bank::*;
use BankType::*;

#[derive(Debug)]
enum BankType {
    Switch(usize),
    Fixed(usize),
    Null
}

// https://www.nesdev.org/wiki/MMC1#Variants
#[derive(Debug)]
enum Bank {
    Ram((BankType, BankType)),
    Rom((BankType, BankType)) 
}

// MMC1 with 512K(PRG-ROM) was supported by re-using a line from the CHR banking controls. 
// https://www.nesdev.org/wiki/MMC1
#[derive(Debug)]
pub struct MMC1 {
    sr: u8,
    is_variant: bool,
    prg_addr: Bank,
    chr_addr: Bank,
    prg_ram: [u8; 0x8000],
    prg_rom: Vec<u8>, 
    chr_ram: Option<[u8; 0x20000]>, // 128KB (2**10 * 128)
    chr_rom: Vec<u8>, 
    mirroring: Mirroring
}

impl fmt::Display for MMC1 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "MMC1")
    }
}

impl MMC1 {
    pub fn new(prg_rom: Vec<u8>, chr_rom: Vec<u8>, mirroring: Mirroring) -> Self {
        // (No CHR_ROM) or (CHR_ROM == 8) => Using 8KB variant
        let is_rom = chr_rom.len() != 0;
        let prg_bank = prg_rom.len() / 0x4000;
        let chr_addr = if is_rom { Rom((Null, Null)) } else { Ram((Null, Null)) };
        MMC1 {
            sr: 0x10,
            is_variant: chr_rom.len() == 0 || chr_rom.len() == 8,
            prg_addr: Rom((Switch(0), Fixed(prg_bank))),
            chr_addr,
            mirroring,
            prg_ram: [0; 0x8000],
            prg_rom,
            chr_ram: if chr_rom.len() == 0 { Some([0; 0x20000]) } else { None } , 
            chr_rom,
        } 
    }

    fn set_variant(&mut self, value: u8, ignore: bool, bank: u8) {
        // todo
        if bank == 1 && ignore { return }

    }

    fn set_reg(&mut self, reg: u16, value: u8) {
        match reg {
            0 => { // Control register
                match value & 0x03 {
                    0 => self.mirroring = Mirroring::OneScreenLower,
                    1 => self.mirroring = Mirroring::OneScreenUpper,
                    2 => self.mirroring = Mirroring::Vertical,
                    3 => self.mirroring = Mirroring::Horizontal,
                    _ => ()
                };
                match (value & 0x0C) >> 2 {
                    0 | 1 => self.prg_addr = Rom((Switch(0), Null)),
                    2 => self.prg_addr = (Fixed(Rom(0)), Switch(Rom(0))),
                    3 => self.prg_addr = (Switch(Rom(0)), Fixed(Rom(self.prg_rom.len() / 0x4000))),
                    _ => ()
                }
                match (value & 0x10) >> 4 {
                    0 => self.chr_addr = {
                        if self.chr_ram.is_none() {
                            (Switch(Rom(0)), Null)
                        } else {
                            (Switch(Ram(0)), Null)
                        }
                    },
                    1 => self.chr_addr = {
                        if self.chr_ram.is_none() {
                            (Switch(Rom(0)), Switch(Rom(0x1000)))
                        } else {
                            (Switch(Ram(0)), Switch(Ram(0x1000)))
                        }
                    },
                    _ => ()
                }
            },
            1 => { // CHR bank 0 register
                // High Address lines are used for different purposes
                if !self.is_variant {
                    match self.chr_addr {
                        (Switch(Rom(_)), Null) => {
                            let bank = (value & 0x1E) as usize;
                            self.chr_addr = (Switch(Rom(bank * CHR_BANK_SIZE)), Null);
                        },
                        (Switch(Ram(_)), Null) => {
                            let bank = (value & 0x1E) as usize;
                            self.chr_addr = (Switch(Ram(bank * CHR_BANK_SIZE)), Null);
                        },
                        (Switch(Rom(_)), b) => {
                            let bank  = (value & 0x1F) as usize;
                            self.chr_addr = (Switch(Rom(bank * CHR_BANK_SIZE)), b);
                        },
                        (Switch(Ram(_)), b) => {
                            let bank  = (value & 0x1F) as usize;
                            self.chr_addr = (Switch(Ram(bank * CHR_BANK_SIZE)), b);
                        },
                        _ => ()
                    }
                }
                else {
                    match self.chr_addr {
                        (_, Null) => {
                            let bank = (value & 0x1E) as usize;
                            self.prg_addr = (Switch(bank * CHR_BANK_SIZE), Null);
                        },
                        (Switch(_), b) => {
                            let bank  = (value & 0x1F) as usize;
                            self.prg_addr = (Switch(bank * CHR_BANK_SIZE), b);
                        },
                        _ => ()
                    }
                }
            },
            2 => { // CHR bank 1 register
                match self.prg_addr {
                    (_, Null) => (),
                    (a, Switch(_)) => {
                        let bank  = (value & 0x1F) as usize;
                        self.prg_addr = (a, Switch(bank * CHR_BANK_SIZE));
                    },
                    _ => () 
                }
            }, 
            3 => { // PRG bank register
                match self.prg_addr {
                    (_, Null) => {
                        let bank = (value & 0xE) as usize;
                        self.prg_addr = (Switch(bank * PRG_BANK_SIZE), Null);
                    },
                    (a, Switch(_)) => {
                        let bank  = (value & 0xF) as usize;
                        self.prg_addr = (a, Switch(bank * PRG_BANK_SIZE));
                    },
                    (Switch(_), b) => {
                        let bank  = (value & 0xF) as usize;
                        self.prg_addr = (Switch(bank * PRG_BANK_SIZE), b);
                    }
                    _ => ()
                }
            },
            _ => { panic!("MMC1: Unknown register."); }
        };
    }

    fn update_sr(&mut self, value: u8, addr: u16) {
        if (value & 0x7) != 0 { self.sr = 0x10; return; }
        if self.sr & 1 == 1 {
            self.sr >>= 1;
            self.sr |= (value & 0x1) << 4;
            let reg = ((addr & 0xF000) >> 13) - 4;
            self.set_reg(reg, self.sr);
            self.sr = 0x10;
        } else {
            self.sr >>= 1;
            self.sr |= (value & 0x1) << 5;
        }
    }
}

impl Mapper for MMC1 {
    fn get_mirroring(&self) -> Mirroring { self.mirroring }

    fn read_chr(&self, addr: u16) -> u8 { 
        match self.chr_addr {
            (Switch(x), Null) => { self.chr[x + addr as usize] },
            (Fixed(_), None) => { self.chr[addr as usize] },
            (Switch(x), Some(Switch(y))) => { 
                if addr >= 0x1000 { 
                    let diff = (addr - 0x1000) as usize;
                    self.chr[y + diff] 
                } else { 
                    self.chr[x + addr as usize] 
                }
            }
            _ => { 
                log("MMC1: Unknown CHR read."); panic!(); 
            }
        }
    }

    fn read_prg(&self, addr: u16) -> u8 { 
        log(&format!("{addr:#06x}"));
        if addr >= 0x6000 && addr <= 0x7FFF { return self.prg_ram[(addr -  0x6000) as usize]; }
        match &self.prg_addr {
            (Switch(x), None) => { 
                let diff = (addr - 0x8000) as usize;
                self.prg_rom[x + diff] 
            },
            (Fixed(x), Some(Switch(y))) => {
                if addr >= 0xC000 { 
                    let diff = (addr - 0xC000) as usize;
                    self.prg_rom[y + diff] 
                } else { 
                    let diff = (addr - 0x8000) as usize;
                    self.prg_rom[x + diff] 
                } 
            }
            (Switch(x), Some(Fixed(y))) => { 
                if addr >= 0xC000 { 
                    let diff = (addr - 0xC000) as usize;
                    self.prg_rom[y + diff] 
                } else { 
                    let diff = (addr - 0x8000) as usize;
                    self.prg_rom[x + diff] 
                }
            }
            (b1, b2) => { 
                log(&format!("{:?}, {:?}", b1, b2)); 
                log("MMC1: Unknown PRG ROM read."); 
                panic!(); 
            }
        }
    }

    // CPU $6000-$7FFF: 8 KB PRG RAM bank.
    fn write_prg(&mut self, addr: u16, val: u8) { 
        self.update_sr(val, addr);
    }

    // MMC1 can do CHR banking in 4KB chunks. Known carts with CHR RAM have 8 KiB, so that makes 2 banks. RAM vs ROM doesn't make any difference for address lines.
    fn write_chr(&mut self, addr: u16, val: u8) { self.chr[addr as usize] = val; }
    // fn write_chr(&mut self, addr: u16, val: u8) { }
}
